// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.20;

import "forge-std/Test.sol";
import "../src/MyToken.sol";
import "../src/TokenBank.sol";
import "../src/NFTMarket.sol";
import "@openzeppelin/contracts/token/ERC721/ERC721.sol";


/// 测试用 NFT
contract TestNFT is ERC721 {
    uint256 public nextId;
    constructor() ERC721("TestNFT", "TNFT") {}

    function mint(address to) external {
        _mint(to, nextId++);
    }
}


contract PermitTest is Test {
    MyToken token;
    TokenBank bank;
    NFTMarket market;
    TestNFT nft;

    address user = vm.addr(1);
    uint256 userPk = 1;
    address projectSigner = vm.addr(2);
    uint256 projectPk = 2;

    function setUp() public {
        token = new MyToken(1e24); // 100w token
        bank = new TokenBank(address(token));
        market = new NFTMarket(address(token), projectSigner);
        nft = new TestNFT();

        // 给用户一些 token 和 nft
        token.transfer(user, 1e21); // 1000 token
        nft.mint(user);
    }

    /// 测试 ERC20Permit + TokenBank 存款
    function test_permitDeposit() public {
        uint256 amount = 1e20; // 100 token
        uint256 nonce = token.nonces(user);
        uint256 deadline = block.timestamp + 1 hours;

        // EIP712 digest
        bytes32 digest = keccak256(
            abi.encodePacked(
                "\x19\x01",
                token.DOMAIN_SEPARATOR(),
                keccak256(abi.encode(
                    keccak256("Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)"),
                    user,
                    address(bank),
                    amount,
                    nonce,
                    deadline
                ))
            )
        );

        (uint8 v, bytes32 r, bytes32 s) = vm.sign(userPk, digest);

        vm.prank(user);
        bank.permitDeposit(amount, deadline, v, r, s);

        assertEq(bank.balances(user), amount);
    }

    /// 测试 NFTMarket 白名单签名购买
    function test_permitBuy() public {
        // user 拥有 NFT，list 出售
        vm.startPrank(user);
        nft.approve(address(market), 0);
        market.list(address(nft), 0, 100);
        vm.stopPrank();

        // 给 user 一些 token 授权
        vm.startPrank(user);
        token.approve(address(market), 100);
        vm.stopPrank();

        uint256 deadline = block.timestamp + 1 hours;

        // 项目方对 (buyer, nft, tokenId, deadline) 签名
        bytes32 message = keccak256(abi.encodePacked(user, address(nft), uint256(0), deadline));
        bytes32 ethHash = keccak256(abi.encodePacked("\x19Ethereum Signed Message:\n32", message));

        (uint8 v, bytes32 r, bytes32 s) = vm.sign(projectPk, ethHash);

        // user 调用 permitBuy
        vm.prank(user);
        market.permitBuy(address(nft), 0, deadline, v, r, s);

        // 断言 NFT 转移
        assertEq(nft.ownerOf(0), user);
    }
}
